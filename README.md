# SELAB-Refactoring

## ریفکتور ها
برای شروع در راستای Separate Query From Modifier،دو متد getTemp و getDateAddress را به دو متد میشکنیم و هرجا متد اولی کال شده بود هردو متد رو باهم کال میکنیم.( دو مورد ریفکتور)
![image](https://github.com/mohammadhnz/SELAB-Refactoring/assets/59181719/211c24f1-3aad-49cd-8bdc-9cbad596cbf6)

سپس در راستای اینکه switch-case را از بین ببریم از Polymorphism استفاده میکنیم. به این صورت که سه نوع مختلف Action تعریف میکنیم.(یک مورد ریفکتور) در نتیجه داریم:
![image](https://github.com/mohammadhnz/SELAB-Refactoring/assets/59181719/1060d088-3be9-4847-a2d4-e14c03dea440)


سپس در قدم بعدی یک facade برای SemanticSymbol تعریف میکنیم تا symbolTable و کل پکیج را wrap کند تا از هیچ کجا، importای بغیر از این کلاس نداشته باشیم در این پکیچ.
![image](https://github.com/mohammadhnz/SELAB-Refactoring/assets/59181719/636378b3-aee0-4462-a7c1-ecba862cff15)

برای facade بعدی، برای کلاس CodeGenerator یک Facade تعریف میکنیم که وظیفه wrap کردن کلاس CodeGenerator را دارد.
![image](https://github.com/mohammadhnz/SELAB-Refactoring/assets/59181719/559566d4-2645-4f5c-af79-d83349a3ae83)

در قدم بعدی در parser، اکشن‌های مختلف پشت سر هم کال شده بودن داخل شرط if، در نتیجه اینارو میایم و extract method میکنیم:
![image](https://github.com/mohammadhnz/SELAB-Refactoring/assets/59181719/1eecf504-37c3-44ae-a948-a4622577921f)

همینطور یک کار دیگر در CodeGenerator این بود که پرینت ارور در همه‌جا انجام شده بود، یک method extract ساده انجام میدهیم تا این موضوع از کد جدا شود.
![image](https://github.com/mohammadhnz/SELAB-Refactoring/assets/59181719/24642dd6-a2fd-46bb-b6dc-d306d6b0afd2)

در قدم بعدی طبق اصل self-encapsulated-field برای متغییر های پارسر getter و setter تعریف میکنیم و سپس متد‌هایی که برای هندل actionها (reduce, shift, accept) وجود داشتند را hide delegate میکنیم و در نهایت هم یک کلاس ActionHandler ایجاد میکنیم:
![image](https://github.com/mohammadhnz/SELAB-Refactoring/assets/59181719/a355d0ff-c89a-45e0-8a9d-ef14a16ed598)

## بخش تئوری
### سوال اول
کد تمیز: به کدی که به راحتی قابل خواندن، قابل فهم و قابل نگه‌داری باشد، کد تمیز گویند.همینطور این کد باید از ساختار بهره‌مند باشد و از best practice ها پیروی کند.
بدهی فنی: هنگامی که بخاطر عجله در پیاده‌سازی یا کمبود منابع، راه‌حلی بغیر از بهترین راه‌حل ممکن استفاده میکنیم، ممکن هست پیچیپگی، غیربهینگی، کد کثیف و... به سیستم اضافه بشود. به کار‌هایی که در حال حاضر برای بهینه‌کردن، تمیز کردن، کاهش پیچیدگی و ... که باید انجام شوند بدهی فنی میگویند. اگر بدهی فنی افزایش یابد، افزونگی پیچیدگی باعث کاهش سرعت و یا توقف توسعه میشود.
بوی بد: اشارهه به اشکالات طراحی و یا غیربهینگی یا حتی اشکالات clean code در کد دارد.
### سوال دوم
دسته Bloaters: اشاره به کدها، توابع یا کلاس‌های بسیار بزرگی دارد که این بزرگی باعث غیرقابل توسعه در آن‌ها میشود دارد. یعنی مثلا وقتی یک متد ده‌ها variable دارد، یا وقتی یک کلاس 30 متد دارد این‌ها از دسته مشکلات این دسته هستند که باید یا کلاس‌ها را بشکنیم، یا متد‌هارا تبدیل به کلاس‌های مجزا کنیم یا از راه‌حل‌های دیگر استفاده کنیم.
دسته Object-Oriented-Abusers: استفاده‌های نادرست یا ناقص از اصول شی‌گرایی هستند. میتوان به switch-caseها اشاره کرد، و یا منطق یکسان با اسم‌های متفاوت و ...
دسته Change Preventers: اشاره به این دارد که وقتی میخواهیم یک مورد خیلی کوچک را در کد تغییر دهیم باید تغییرات بسیار زیادی را در کد انجام دهیم. این اتفاق سرعت توسعه را بسیار کاهش میدهد.
دسته Dispensables: کدهایی که استفاده‌ای ندارند و پاک شدن آن‌ها باعث کاهش حجم کد، افزایش خوانایی و تمیزی کد میشود. میتوان از این دسته مشکلات به duplicate code, comments و... اشاره کرد.
دسته Couplers: در این دسته اشاره به مشکلات coupling زیاد در کلاس‌ها دارد و نشان میدهد اگر delegation استفاده شود چه اتفاقی میافتد.
### سوال سوم

مشکل Lazy Class در دسته بو‌های Dispensables قرار میگیرد. برای بازآرایی اینگونه کلاس‌ها به inline class و collapse hiearchy اشاره شده‌است. در واقع در این کیس‌ها بایستی یا کل کلاس‌‌را inline بکنیم یا در صورتی subclassهایی با ویژگی‌های بیسار‌ کمی وجود دارند میتوان variable و methodهای آن‌ها را به کلاس بالاتر منتقل کرد و آن کلاس را حذف کرد. در مواقعی که یک Lazy Class در راستای توسعه‌های آینده ایجاد شده‌است بایستی آن را نگه داشت و آن را بازآرایی نکرد. در واقع در این موارد باید بین سادگی و شفافیت کد تعادل نگه‌داشت.
